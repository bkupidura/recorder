package pool

import (
	"context"
	"fmt"
	"sync"
)

// Pool is simple workpool.
type Pool struct {
	noWorkers  int
	running    bool
	chDone     chan bool
	chResult   chan interface{}
	chWork     chan func(context.Context, chan interface{}) error
	mu         sync.Mutex
	errors     int64
	inProgress int
	ctx        context.Context
}

// New creates new Pool.
func New(opts *Options) *Pool {
	p := &Pool{
		noWorkers:  opts.NoWorkers,
		running:    false,
		chDone:     make(chan bool, 1),
		chResult:   make(chan interface{}, opts.ResultSize),
		chWork:     make(chan func(context.Context, chan interface{}) error, opts.PoolSize),
		errors:     0,
		inProgress: 0,
		ctx:        opts.Ctx,
	}

	go p.spawnWorkers()

	return p
}

// spawnWorkers starts goroutines responsible for executing tasks from workpool.
func (p *Pool) spawnWorkers() {
	p.running = true
	var wg sync.WaitGroup

	for i := 0; i < p.noWorkers; i++ {
		wg.Add(1)

		go func() {
			defer wg.Done()

			for {
				select {
				// When new work is received, start execution.
				case work := <-p.chWork:
					p.mu.Lock()
					p.inProgress++
					p.mu.Unlock()

					err := work(p.ctx, p.chResult)

					p.mu.Lock()
					p.inProgress--
					if err != nil {
						p.errors++
					}
					p.mu.Unlock()
					// When channel is closed, stop worker.
					// Only used in tests.
				case <-p.chDone:
					return
				}
			}
		}()
	}

	wg.Wait()
	p.running = false
}

// stop all workers in pool.
func (p *Pool) stop() {
	close(p.chDone)
}

// Running returns if pool is running (have any working worker)
func (p *Pool) Running() bool {
	return p.running
}

// Errors returns total number of errors generated by tasks in workingpool.
func (p *Pool) Errors() int64 {
	return p.errors
}

// InProgress returns how many tasks are currently running.
func (p *Pool) InProgress() int {
	return p.inProgress
}

// WorkBacklog returns number of queued tasks.
func (p *Pool) WorkBacklog() int {
	return len(p.chWork)
}

// Execute add task to working pool queue.
func (p *Pool) Execute(task func(context.Context, chan interface{}) error) error {
	if len(p.chWork) == cap(p.chWork) {
		return fmt.Errorf("pool is full, unable to add new task")
	}
	p.chWork <- task
	return nil
}

// ResultChan returns channel where all results are published.
func (p *Pool) ResultChan() chan interface{} {
	return p.chResult
}
